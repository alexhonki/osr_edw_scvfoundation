PROCEDURE "osr.scv.foundation.db.Procedures::SP_GenerateScvSubgroupsV20" (
	IN i_match_group		INTEGER DEFAULT 0, 
	OUT o_return_code		NVARCHAR(128), 			-- 0 = execution successful; 1 = execution raised exception.
	OUT o_message			NVARCHAR(1000) 			-- message
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   AS
BEGIN SEQUENTIAL EXECUTION
	/**************************************************************************************************************************************************
	Generate SCV subgroups Version 2 -Using Graphs
	
	Create subgroups for all match rows within a match group:
	
		1. Copy all the entities that are to be analysed to table MatchReviewRelationships
		
		2. Remove all weak links
		
		3. Complete the Graph table - with the vertices
		
		4. Update subgroup table with groups created by Tranversing graph breadth-first
		
	***************************************************************************************************************************************************

	Change log:
   
	28.09.2018 - R.Silva - SI007 - Build procedure
	
	***************************************************************************************************************************************************/

	
	DECLARE l_count_rules	INTEGER;
	DECLARE l_total_rules	INTEGER;
	
	DECLARE l_policy_name	NVARCHAR(256);
	
	DECLARE l_empty_list	BOOLEAN;
	
	DECLARE l_min_score		INTEGER;
	
	DECLARE v_total_groups	integer;
	DECLARE v_count_groups	integer;
	DECLARE v_vertice  		integer;


	-- error handler
   	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		o_return_code :=  'ERROR';
		o_message:=  'ERROR: ' || ::SQL_ERROR_CODE || ' ' || ::SQL_ERROR_MESSAGE;
	END;
	
	
	-- standardise input
	IF (:i_match_group IS NULL) THEN
		I_MATCH_GROUP = 0;
	END IF;
	
	
	/*********************************************************************************************************************
		1. Copy all the entities that are to be analysed to table MatchReviewRelationships
	***********************************************************************************************************************/
	
	-- delete relationships table
	TRUNCATE TABLE "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships";
	
	-- reset sequence
	-- EXECUTE IMMEDIATE 'ALTER SEQUENCE "osr.scv.foundation.db.data::SEQ_MatchTracingRelationships" RESTART WITH 1';
	
	-- copy edges from relationships
	IF :i_match_group  = 0 OR  :i_match_group  IS NULL THEN
	
		-- read all records
		lt_relationships = 
			SELECT		"osr.scv.foundation.db.data::SEQ_MatchTracingRelationships".NEXTVAL as "ID",
						r."Match_ROW_ID" as "MATCH_ROW_ID",
						t."RELATED_ROW_ID",
						t."POLICY_NAME",
						t."RULE_NAME",
						t."SCORE",
						r.GROUP_ID
			FROM		"osr.scv.foundation.db.data::MatchResults.MatchResults"	AS r
			LEFT OUTER JOIN "osr.scv.foundation.db.data::MatchResults.MatchTracing" AS t
			ON			t."ROW_ID" = r."Match_ROW_ID";			

		
		-- Empty Sub-Groups table ... will rework all subgroups
		TRUNCATE TABLE "osr.scv.foundation.db.data::MatchResults.SubGroups";
		
	ELSE
	
		-- limit the select to the records matching L_match_group
		-- INSERT INTO "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships" 
		lt_relationships = 
			SELECT		"osr.scv.foundation.db.data::SEQ_MatchTracingRelationships".NEXTVAL as "ID",
						r."Match_ROW_ID" as "MATCH_ROW_ID",
						t."RELATED_ROW_ID",
						t."POLICY_NAME",
						t."RULE_NAME",
						t."SCORE",
						r.GROUP_ID
			FROM		"osr.scv.foundation.db.data::MatchResults.MatchResults"	AS r
			LEFT OUTER JOIN "osr.scv.foundation.db.data::MatchResults.MatchTracing" AS t
			ON			t."ROW_ID" = r."Match_ROW_ID"
			WHERE		r."GROUP_ID"	= :i_match_group ;

		-- delete only the records included in L_match_group
		DELETE	FROM "osr.scv.foundation.db.data::MatchResults.SubGroups"
		WHERE	"MATCH_ROW"
		IN		(
			SELECT	"MATCH_ROW_ID" as "MATCH_ROW"
			FROM	:lt_relationships
			UNION	ALL
			SELECT	"RELATED_ROW_ID" as "MATCH_ROW"
			FROM	:lt_relationships
		);

	END IF;
	
	/***********************************************************************************************************************
		2. Identify all weak links
	***********************************************************************************************************************/
	
	-- first read all rules (they should be three to start with)
	lt_rules =
		SELECT	"POLICY_NAME",
				"MIN_SCORE",
				row_number() OVER (Order by POLICY_NAME) As row_number   -- get a counter that will be used to access data
		FROM	"osr.scv.foundation.db.data::MatchResults.MatchWeakLinksPolicies";
	
	-- count total number of rules
	SELECT	count(row_number)
	INTO	l_total_rules
	FROM	:lt_rules;	
	
	-- start with one
	l_count_rules = 1;
	
	-- list of deletions is empaty
	l_empty_list = TRUE;
	
	-- loop over rules
	WHILE :l_count_rules <= :l_total_rules DO
		
		-- read next rule
		SELECT "POLICY_NAME",
				"MIN_SCORE"
		INTO	l_policy_name,
				l_min_score
		FROM	:lt_rules
		WHERE	 row_number = l_count_rules;
		
		IF l_empty_list = TRUE THEN
			-- delete links that match that rule data based on read rule
			-- DELETE	FROM "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships"
			
			lt_deletions = 
			SELECT	"ID", "GROUP_ID"
			FROM	:lt_relationships -- "osr.scv.foundation.db.data::SEQ_MatchTracingRelationships"
			WHERE	"POLICY_NAME" = l_policy_name
			AND		SCORE		< :l_min_score; 	
			
			l_empty_list = FALSE;
			
		ELSE
			lt_deletions = 
			SELECT	"ID", "GROUP_ID"
			FROM	:lt_deletions
			UNION ALL
			SELECT	"ID", "GROUP_ID"
			FROM	:lt_relationships -- "osr.scv.foundation.db.data::SEQ_MatchTracingRelationships
			WHERE	"POLICY_NAME" = l_policy_name
			AND		SCORE		< :l_min_score; 
			
		END IF;
		
		-- increment counter
		l_count_rules = :l_count_rules + 1;
		
	END WHILE;
	
	/***********************************************************************************************************************
		3. Split lists .. only the ones with deletions will remain in the GRAPH for analysis
	***********************************************************************************************************************/	
	
	-- GROUPS that include deletions ... will go to osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships
	INSERT	INTO "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships" 
	SELECT		"ID",
				"MATCH_ROW_ID",
				"RELATED_ROW_ID",
				"POLICY_NAME",
				"RULE_NAME",
				"SCORE"
	FROM		:lt_relationships
	WHERE		"RELATED_ROW_ID" IS NOT NULL -- these were rows that belong to original groups but that have no outward relationship
	AND			ID	NOT IN -- do not copy the weak links
	(   
		SELECT 	"ID" 
		FROM	:lt_deletions
	)	
	AND			"GROUP_ID" IN -- but ONLY copy GROUPS that do have weak links
	(
		SELECT 	DISTINCT "GROUP_ID" 
		FROM	:lt_deletions
	);
	
	-- query var for groups with 1 component
	lt_groups_with_1 = 
		SELECT	DISTINCT("MATCH_ROW_ID")	AS "MATCH_ROW",
				"GROUP_ID"
		FROM	:lt_relationships
		WHERE	"GROUP_ID" NOT IN -- ONLY copy GROUPS that do NOT have weak links
		(
			SELECT 	DISTINCT "GROUP_ID" 
			FROM	:lt_deletions
		); 
		
	-- GROUPS that DO NOT include deletions ... will go straight to SubGroupss
	INSERT	INTO "osr.scv.foundation.db.data::MatchResults.SubGroups"
	SELECT	DISTINCT("MATCH_ROW"),
			-1 * "GROUP_ID" 	AS "GROUP_TAG"  -- multiply by -1 to avoid collisions with new keys 
	FROM	:lt_groups_with_1;	
	
	/***********************************************************************************************************************
		3. Complete the Graph table with all vertices 
	***********************************************************************************************************************/

	TRUNCATE TABLE  "osr.scv.foundation.db.data::MatchResults.MatchTracingRows";
	
	INSERT INTO "osr.scv.foundation.db.data::MatchResults.MatchTracingRows"
	SELECT		DISTINCT("MATCH_ROW_ID") AS "MATCH_ROW_ID",
				"GROUP_ID"
	FROM		:lt_relationships
	WHERE "GROUP_ID" IN -- but ONLY copy GROUPS that do have weak links
	(
		SELECT 	DISTINCT "GROUP_ID" 
		FROM	:lt_deletions
	);	

	
	
	/***********************************************************************************************************************
		4. Update subgroup table with groups created by Tranversing graph breadth-first
	***********************************************************************************************************************/

	-- get all roots from table function "Matrch Vertices"
	vertices =	
		SELECT		"MATCH_ROW",
					row_number() OVER (Order by "MATCH_ROW") As row_number
		FROM		"osr.scv.foundation.db.functions::MatchVertices"();  -- Table function that returns all vertices (roots)
	
	-- count how many vertices were returned by the previous query
	SELECT	count(*) 
	INTO	V_TOTAL_GROUPS
	FROM	:vertices;

	
	-- now update SUB_GROUP by subgroup
	if v_total_groups >= 1 then

		-- stargint from one
		v_count_groups = 1;
		
		-- crazy way to do a cursor
		WHILE :v_count_groups <= :v_total_groups DO
		
			-- get next root
			SELECT	"MATCH_ROW" 
			INTO	V_VERTICE     -- this is the vertice
			FROM	:VERTICES
			WHERE	row_number =  v_count_groups; -- NEXT ROW
				
				-- breath first search of all nodes that are part of the new group
				lt_new_groupS =
					SELECT 	"PARENT",
							"MATCH_ROW",
							MIN("DEPTH")
					FROM	"osr.scv.foundation.db.views::MatchTrackingBFT"
							(placeholder."$$startVertice$$"=> :V_VERTICE)
					GROUP BY "PARENT" , "MATCH_ROW";
					
				-- group(s) that already exist in the groups table and contain any of the MATCH_ROWS from the new group
				lt_existing_groups = 
					SELECT	"GROUP_TAG",
							"MATCH_ROW"
					FROM	 "osr.scv.foundation.db.data::MatchResults.SubGroups"
					WHERE	"MATCH_ROW"
					IN
					(
						SELECT	"MATCH_ROW"
						FROM	:lt_new_groupS
					);
				
				-- delete existing groups
				-- they will be readded with the new group number
				DELETE FROM "osr.scv.foundation.db.data::MatchResults.SubGroups"
				WHERE		"GROUP_TAG"
				IN 
				(
					SELECT DISTINCT "GROUP_TAG"
					FROM			:lt_existing_groups
				);
				
					
				-- now add the group again with the new group number
				INSERT	INTO "osr.scv.foundation.db.data::MatchResults.SubGroups"
				(
					SELECT	DISTINCT "MATCH_ROW",
							:V_VERTICE AS "GROUP_TAG"
					FROM	
					(
						SELECT	"MATCH_ROW" 
						FROM	:lt_new_groups
						UNION	ALL
						SELECT	"MATCH_ROW"
						FROM	:lt_existing_groups
					)
					
				);

			-- increament group counter
			v_count_groups = v_count_groups + 1;
		
		END WHILE;
		

	END IF;
	
	
	-- now add the orfaned Groups from  "osr.scv.foundation.db.data::MatchResults.MatchTracingRows

	-- query var for groups with 1 component
	lt_groups_with_1_from_graph = 
		SELECT	DISTINCT("MATCH_ROW"),
				"GROUP_ID"
		FROM	"osr.scv.foundation.db.data::MatchResults.MatchTracingRows"
		WHERE	"MATCH_ROW" NOT IN -- ONLY copy GROUPS that do NOT have weak links
		(
			SELECT 	DISTINCT "MATCH_ROW" 
			FROM	"osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships"
			UNION
			SELECT 	DISTINCT "RELATED_ROW"  AS "MATCH_ROW" 
			FROM	"osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships"			
		); 
		
	-- GROUPS that DO NOT include deletions ... will go straight to SubGroupss
	INSERT	INTO "osr.scv.foundation.db.data::MatchResults.SubGroups"
	SELECT	DISTINCT("MATCH_ROW"),
			-1 * "GROUP_ID" 	AS "GROUP_TAG"  -- multiply by -1 to avoid collisions with new keys 
	FROM	:lt_groups_with_1_from_graph;	


	-- Set return code
	o_return_code	:=  'SUCCESS';
	o_message		:=  'SCV groups created successfully';
	

END