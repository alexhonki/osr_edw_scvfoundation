PROCEDURE "osr.scv.foundation.db.Procedures::SP_GenerateScvSubgroupsV20" (
	IN i_match_group		INTEGER DEFAULT 0, 
	OUT o_return_code		NVARCHAR(128), 			-- 0 = execution successful; 1 = execution raised exception.
	OUT o_message			NVARCHAR(1000) 			-- message
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   AS
BEGIN SEQUENTIAL EXECUTION
	/**************************************************************************************************************************************************
	Generate SCV subgroups Version 2 -Using Graphs
	
	Create subgroups for all match rows within a match group:
	
		1. Copy all the entities that are to be analysed to table MatchReviewRelationships
		
		2. Remove all the weak links
		
		3. Complete the Graph table - with the vertices
		
		4. Update subgroup table with groups created by Tranversing graph breadth-first
		
	***************************************************************************************************************************************************

	Change log:
   
	28.09.2018 - R.Silva - SI007 - Build procedure
	
	***************************************************************************************************************************************************/

	
	DECLARE l_count_rules	INTEGER;
	DECLARE l_total_rules	INTEGER;
	DECLARE l_rule_name		NVARCHAR(50);
	
	DECLARE l_min_score		INTEGER;
	
	DECLARE v_total_groups	integer;
	DECLARE v_count_groups	integer;
	DECLARE v_vertice  		integer;


	-- error handler
   	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		o_return_code :=  'ERROR';
		o_message:=  'ERROR: ' || ::SQL_ERROR_CODE || ' ' || ::SQL_ERROR_MESSAGE;
	END;
	
	
	-- standardise input
	IF (:i_match_group IS NULL) THEN
		I_MATCH_GROUP = 0;
	END IF;
	
	
	/*********************************************************************************************************************
		1. Copy all the entities that are to be analysed to table MatchReviewRelationships
	***********************************************************************************************************************/
	
	-- delete relationships table
	TRUNCATE TABLE "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships";
	
	-- reset sequence
	-- EXECUTE IMMEDIATE 'ALTER SEQUENCE "osr.scv.foundation.db.data::SEQ_MatchTracingRelationships" RESTART WITH 1';
	
	-- copy edges from relationships
	
	IF :i_match_group  = 0 OR  :i_match_group  IS NULL THEN
	
		-- read all records
		INSERT INTO "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships" 
		(
			SELECT		"osr.scv.foundation.db.data::SEQ_MatchTracingRelationships".NEXTVAL, t.*
			FROM		"osr.scv.foundation.db.data::MatchResults.MatchTracing"		AS t
		);
		
		-- Empty Sub-Groups table ... will rework all subgroups
		TRUNCATE TABLE "osr.scv.foundation.db.data::MatchResults.SubGroups";
		
	ELSE
	
		-- limit the select to the records matching L_match_group
		INSERT INTO "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships" 
		(
			SELECT		"osr.scv.foundation.db.data::SEQ_MatchTracingRelationships".NEXTVAL, t.*
			FROM		"osr.scv.foundation.db.data::MatchResults.MatchTracing"	AS t
			INNER JOIN	"osr.scv.foundation.db.data::MatchResults.MatchResults"	AS r
			ON			t."ROW_ID" = r."Match_ROW_ID"
			WHERE	
			(
				:i_match_group  = 0 OR
				r."GROUP_ID"	= :i_match_group 
			)
		);
		
		-- do not emapty table.. we will rely on thi procedure's delta abilities to handle the new records
		
	END IF;
	
	/***********************************************************************************************************************
		2. Remove all the weak links
	***********************************************************************************************************************/
	
	-- first read all rules (they should be three to start with)
	lt_rules =
		SELECT	"RULE_NAME",
				"MIN_SCORE",
				row_number() OVER (Order by RULE_NAME) As row_number   -- get a counter that will be used to access data
		FROM	"osr.scv.foundation.db.data::MatchResults.MatchWeakLinks";
	
	-- count total number of rules
	SELECT	count(row_number)
	INTO	l_total_rules
	FROM	:lt_rules;	
	
	-- start with one
	l_count_rules = 1;
	
	-- loop over rules
	WHILE :l_count_rules <= :l_total_rules DO
		
		-- read next rule
		SELECT "RULE_NAME",
				"MIN_SCORE"
		INTO	l_rule_name,
				l_min_score
		FROM	:lt_rules
		WHERE	 row_number = l_count_rules;
		
		-- delete links that match that rule data based on read rule
		DELETE	FROM "osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships"
		WHERE	"RULE_NAME" = l_rule_name
		AND		SCORE		< :l_min_score; 
		
		-- increment counter
		l_count_rules = :l_count_rules + 1;
		
	END WHILE;
	
	
	/***********************************************************************************************************************
		3. Complete the Graph table with all vertices 
	***********************************************************************************************************************/

	TRUNCATE TABLE  "osr.scv.foundation.db.data::MatchResults.MatchTracingRows";
	
	-- now I am ready to fill up the table of members
	INSERT INTO "osr.scv.foundation.db.data::MatchResults.MatchTracingRows"
	(
		SELECT	DISTINCT "MATCH_ROW"
		
		FROM 
		(
			SELECT	"MATCH_ROW"
			FROM	"osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships"
			UNION	
			SELECT	"RELATED_ROW" AS "MATCH_ROW"
			FROM	"osr.scv.foundation.db.data::MatchResults.MatchTracingRelationships"
		)
	);
	
	

	
	
	/***********************************************************************************************************************
		4. Update subgroup table with groups created by Tranversing graph breadth-first
	***********************************************************************************************************************/

	-- get all roots from table function "Matrch Vertices"
	vertices =	
		SELECT		"MATCH_ROW",
					row_number() OVER (Order by "MATCH_ROW") As row_number
		FROM		"osr.scv.foundation.db.functions::MatchVertices"();  -- Table function that returns all vertices (roots)
	
	-- count how many vertices were returned by the previous query
	SELECT	count(*) 
	INTO	V_TOTAL_GROUPS
	FROM	:vertices;

	
	-- now update SUB_GROUP by subgroup
	if v_total_groups >= 1 then

		-- stargint from one
		v_count_groups = 1;
		
		-- crazy way to do a cursor
		WHILE :v_count_groups <= :v_total_groups DO
		
			-- get next root
			SELECT	"MATCH_ROW" 
			INTO	V_VERTICE     -- this is the vertice
			FROM	:VERTICES
			WHERE	row_number =  v_count_groups; -- NEXT ROW
				
				-- breath first search of all nodes that are part of the new group
				lt_new_groupS =
					SELECT 	"PARENT",
							"MATCH_ROW",
							MIN("DEPTH")
					FROM	"osr.scv.foundation.db.data::MatchTrackingBFT"
							(placeholder."$$startVertice$$"=> :V_VERTICE)
					GROUP BY "PARENT" , "MATCH_ROW";
					
				-- group(s) that already exist in the groups table and contain any of the MATCH_ROWS from the new group
				lt_existing_groups = 
					SELECT	"GROUP_TAG",
							"MATCH_ROW"
					FROM	 "osr.scv.foundation.db.data::MatchResults.SubGroups"
					WHERE	"MATCH_ROW"
					IN
					(
						SELECT	"MATCH_ROW"
						FROM	:lt_new_groupS
					);
				
				-- delete existing groups
				-- they will be readded with the new group number
				DELETE FROM "osr.scv.foundation.db.data::MatchResults.SubGroups"
				WHERE		"GROUP_TAG"
				IN 
				(
					SELECT DISTINCT "GROUP_TAG"
					FROM	:lt_existing_groups
				);
				
					
				-- now add the group again with the new group number
				INSERT	INTO "osr.scv.foundation.db.data::MatchResults.SubGroups"
				(
					SELECT	DISTINCT "MATCH_ROW",
							:V_VERTICE AS "GROUP_TAG"
					FROM	
					(
						SELECT	"MATCH_ROW"
						FROM	:lt_new_groups
						UNION
						SELECT	"MATCH_ROW"
						FROM	:lt_existing_groups
					)
					
				);

			-- increament group counter
			v_count_groups = v_count_groups + 1;
		
		END WHILE;
		

	END IF;
	

	-- Set return code
	o_return_code	:=  'SUCCESS';
	o_message		:=  'SCV groups created successfully';
	

END